!function(n){var e={};function t(i){if(e[i])return e[i].exports;var r=e[i]={i:i,l:!1,exports:{}};return n[i].call(r.exports,r,r.exports,t),r.l=!0,r.exports}t.m=n,t.c=e,t.d=function(n,e,i){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:i})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var i=Object.create(null);if(t.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)t.d(i,r,function(e){return n[e]}.bind(null,r));return i},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s="./src/script/main.js")}({"./src/script/main.js":
/*!****************************!*\
  !*** ./src/script/main.js ***!
  \****************************/
/*! no exports provided */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mesh_list_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mesh-list.js */ \"./src/script/mesh-list.js\");\n/* harmony import */ var _mesh_manager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mesh-manager.js */ \"./src/script/mesh-manager.js\");\n\n\n\nlet mode = 'controle';\nlet clickX = 0;\nlet clickY = 0;\nlet moveX = 0;\nlet moveY = 0;\n\nconst canvas = document.querySelector('#canvas');\nconst raycaster = new THREE.Raycaster();\nconst mouse = new THREE.Vector2();\nconst group = new THREE.Group();\nconst test = new THREE.Group();\nconst meshManager = new _mesh_manager_js__WEBPACK_IMPORTED_MODULE_1__[\"MeshManager\"]();\n\nmouse.x = -1;\nmouse.y = -1;\n\nconst init = () => {\n    document.querySelector('#button').addEventListener('click', () => {\n        mode = mode === 'controle' ? 'view' : 'controle';\n    });\n\n    // レンダラーを作成する\n    const renderer = createRenderer();\n\n    // シーンを作成する\n    const scene = createScene();\n\n    // カメラを作成する\n    const camera = createCamera();\n\n    // 立方体を作成する\n    const box = createBox();\n    \n    // ライトを作成する\n    const directionallight = createDirectionalLight();\n    const ambientLight = createAmbientLight();\n\n    // シーンに追加する\n    scene.add(box);\n    scene.add(test);\n    scene.add(directionallight);\n    scene.add(ambientLight);\n\n    // TODO: スマホ用イベントを追加する\n    canvas.addEventListener('mousedown', mouseDown);\n    canvas.addEventListener('mouseup', mouseUp);\n   \n    tick();\n\n    // 毎フレーム時に実行されるループイベント\n    function tick() {\n        requestAnimationFrame(tick);\n\n        // マウスの位置に応じてオブジェクトを回転\n        // イージングの公式を用いて滑らかにする\n        if(mode === 'controle') {\n\n            box.rotation.x = 0;\n            box.rotation.y = 0;\n\n            // レイキャストを作成する\n            raycaster.setFromCamera(mouse, camera);\n            const intersects = raycaster.intersectObjects(scene.children, true);\n\n            if(intersects.length > 0) {\n                const list = meshManager.getMeshGroup(intersects[0].object);\n\n                const targetGroup = [];\n                let direction = '';\n                let distance = { x: 0, y: 0 };\n\n                if(Math.abs(moveX - clickX) > 50) {\n                    direction = 'horizontal';\n                    distance.x = moveX < clickX ? Math.PI / 2 : Math.PI / 2 * -1; \n                }\n\n                if(Math.abs(moveY - clickY) > 50) {\n                    direction = 'vertical';\n                    distance.y = moveY < clickY ? Math.PI / 2 : Math.PI / 2 * -1; \n                }\n\n                for(const item of list) {\n                    if(item.name !== direction) continue;\n                    item.list.forEach(e => targetGroup.push(e));\n                    item.list.forEach(e => test.add(e));\n\n                    if(direction === 'horizontal') {\n                        test.rotation.x = box.rotation.x;\n                        test.rotation.y = (moveX - clickX) * 0.02;\n                    }\n\n                    if(direction === 'vertical') {\n                        test.rotation.x = (moveY - clickY) * 0.02;\n                        test.rotation.y = box.rotation.y;\n                    }\n                }\n                console.log(test)\n\n                renderer.render(scene, camera);\n\n                for(const item of targetGroup) {\n                    if(direction === 'horizontal') {\n                        item.rotation.x += Math.PI / 2;\n                    }\n\n                    if(direction === 'vertical') {\n                        item.rotation.y += Math.PI / 2;;\n                    }\n                    group.add(item);\n                }\n\n                return;\n            }\n        } else {\n            box.rotation.x = (moveY - clickY) * 0.02;\n            box.rotation.y = (moveX - clickX) * 0.02;\n        }\n    \n        // レンダリング\n        renderer.render(scene, camera);\n    }\n}\n\nconst mouseDown = (event) => {\n    moveX = 0;\n    moveY = 0;\n    clickX = event.pageX;\n    clickY = event.pageY;\n\n    canvas.addEventListener('mousemove', mouseMove, false);\n}\n\nconst mouseMove = (event) => {\n    if(mode === 'controle') {\n        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n    }\n    moveX = event.pageX;\n    moveY = event.pageY;\n}\n\nconst mouseUp = () => {\n    mouse.x = -1;\n    mouse.y = -1;\n\n    canvas.removeEventListener('mousemove', mouseMove, false);\n}\n\n// レンダラーを作成する\nconst createRenderer = () => {\n    const renderer = new THREE.WebGLRenderer({\n        canvas: document.querySelector(\"#canvas\")\n    });\n\n    // TODO: 分離する\n\n    // サイズを取得\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n\n    // レンダラーのサイズを調整する\n    renderer.setPixelRatio(window.devicePixelRatio);　// 設定しないとスマホでぼやける\n    renderer.setSize(width, height);\n\n    return renderer;\n}\n\nconst createScene = () => {\n    return new THREE.Scene();\n}\n\n// カメラを作成する\nconst createCamera = () => {\n    const width = window.innerWidth;\n    const height = window.innerHeight;\n\n    const angle = 45;\n    const aspect = width / height;\n    const renderStartdist = 1;\n    const renderStopdist = 10000;\n\n    const camera = new THREE.PerspectiveCamera(angle, aspect, renderStartdist, renderStopdist);\n    camera.position.set(0, 0, +1000);\n    \n    return camera;\n}\n\n// 立方体を作成する\nconst createBox = () => {\n    const width = 100;\n    const height = 100;\n    const depth = 100;\n\n    const list1 = new _mesh_list_js__WEBPACK_IMPORTED_MODULE_0__[\"MeshList\"]('vertical');\n    const list2 = new _mesh_list_js__WEBPACK_IMPORTED_MODULE_0__[\"MeshList\"]('vertical');\n    const list3 = new _mesh_list_js__WEBPACK_IMPORTED_MODULE_0__[\"MeshList\"]('vertical');\n    const list4 = new _mesh_list_js__WEBPACK_IMPORTED_MODULE_0__[\"MeshList\"]('horizontal');\n    const list5 = new _mesh_list_js__WEBPACK_IMPORTED_MODULE_0__[\"MeshList\"]('horizontal');\n    const list6 = new _mesh_list_js__WEBPACK_IMPORTED_MODULE_0__[\"MeshList\"]('horizontal');\n    meshManager.add(list1);\n    meshManager.add(list2);\n    meshManager.add(list3);\n    meshManager.add(list4);\n    meshManager.add(list5);\n    meshManager.add(list6);\n\n    // TODO: 簡潔にする\n    for(let i = 0; i < 3; i++) {\n        for(let j = 0; j < 3; j++) {\n            for(let k = 0; k < 3; k++) {\n                // 立方体を作成\n                const geometry = new THREE.BoxGeometry(width, height, depth);\n\n                // const materials = [\n                //     new THREE.MeshStandardMaterial({color: 0x00ff00}),\n                //     new THREE.MeshStandardMaterial({color: 0x00ff00}),\n                //     new THREE.MeshStandardMaterial({color: 0x0000ff}),\n                //     new THREE.MeshStandardMaterial({color: 0x0000ff}),\n                //     new THREE.MeshStandardMaterial({color: 0xff0000}),\n                //     new THREE.MeshStandardMaterial({color: 0xff0000})\n                // ];\n\n                const loader = new THREE.TextureLoader();\n                const texture = loader.load('../img/cube.jpg');\n                // マテリアルにテクスチャーを設定\n                const material = new THREE.MeshStandardMaterial({\n                  map: texture\n                });\n              \n                const mesh = new THREE.Mesh(geometry, material);\n                group.add(mesh);\n\n                if(i === 0) {\n                    mesh.position.z = width * - 1 ;\n                } \n\n                if(i === 1){\n                    mesh.position.z = 0;\n                } \n\n                if(i === 2){\n                    mesh.position.z = width;\n                }\n\n                if(j === 0) {\n                    mesh.position.y = height * -1;\n                    list4.add(mesh);\n                }\n                \n                if(j === 1){\n                    mesh.position.y = 0;\n                    list5.add(mesh);\n                }\n                \n                if(j === 2){\n                    mesh.position.y = height;\n                    list6.add(mesh);\n                }\n\n                if(k === 0) {\n                    mesh.position.x = depth * - 1;\n                    list1.add(mesh);\n                } \n\n                if(k === 1){\n                    mesh.position.x = 0;\n                    list2.add(mesh);\n                }\n                \n                if(k === 2){\n                    mesh.position.x = depth;\n                    list3.add(mesh);\n                }\n            }\n        }\n    }\n\n    return group;\n}\n\n// 平行光源を作成する\nconst createDirectionalLight = () => {\n    const color = 0xffffff;\n    const light = new THREE.DirectionalLight(color);\n\n    // TODO: 分離する\n\n    // 光の強さを2倍にする\n    light.intensity = 2;\n\n    // ライトの位置を変更\n    light.position.set(1, 1, 1);\n\n    return light;\n}\n\n// 環境光源を作成する\nconst createAmbientLight = () => {\n    const color = 0xffffff;\n    const light = new THREE.AmbientLight(color);\n\n    // TODO: 分離する\n\n    // 光の強さを2倍にする\n    light.intensity = 0.5;\n\n    // ライトの位置を変更\n    light.position.set(1, 1, 1);\n\n    return light;\n}\n\nwindow.addEventListener(\"DOMContentLoaded\", init);\n\n\n// window.addEventListener('resize', onResize);\n// function onResize() {\n//   // サイズを取得\n//   const width = window.innerWidth;\n//   const height = window.innerHeight;\n\n//   // レンダラーのサイズを調整する\n//   renderer.setPixelRatio(window.devicePixelRatio);\n//   renderer.setSize(width, height);\n\n//   // カメラのアスペクト比を正す\n//   camera.aspect = width / height;\n//   camera.updateProjectionMatrix();\n// }\n\n\n//# sourceURL=webpack:///./src/script/main.js?")},"./src/script/mesh-list.js":
/*!*********************************!*\
  !*** ./src/script/mesh-list.js ***!
  \*********************************/
/*! exports provided: MeshList */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshList", function() { return MeshList; });\nclass MeshList {\n    constructor(name) {\n        this.name = name;\n        this.list = [];\n    }\n\n    add(item) {\n        this.list.push(item);\n    }\n\n    remove(item) {\n        this.list = this.list.filter(e => e !== item);\n    }\n}\n\n\n//# sourceURL=webpack:///./src/script/mesh-list.js?')},"./src/script/mesh-manager.js":
/*!************************************!*\
  !*** ./src/script/mesh-manager.js ***!
  \************************************/
/*! exports provided: MeshManager */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshManager", function() { return MeshManager; });\nclass MeshManager {\n    constructor() {\n        this.list = [];\n    }\n\n    add(item) {\n        this.list.push(item);\n    }\n\n    remove(item) {\n        this.list = this.list.filter(e => e !== item);\n    }\n\n    getMeshGroup(item) {\n        const result = [];\n        for(const e of this.list) {\n            if(e.list.includes(item) === false) continue;\n            result.push(e);\n        }\n        return result;\n    }\n}\n\n\n//# sourceURL=webpack:///./src/script/mesh-manager.js?')}});